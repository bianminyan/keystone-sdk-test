"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransportWebUSB_instances, _a, _TransportWebUSB_send;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportWebUSB = exports.Chain = exports.StatusCode = exports.Actions = void 0;
const buffer_1 = require("buffer");
const hw_transport_error_1 = require("@keystonehq/hw-transport-error");
const frame_1 = require("./frame");
const constants_1 = require("./constants");
const webusb_1 = require("./webusb");
const helper_1 = require("./helper");
const decorators_1 = require("./decorators");
var actions_1 = require("./actions");
Object.defineProperty(exports, "Actions", { enumerable: true, get: function () { return actions_1.Actions; } });
__exportStar(require("./webusb"), exports);
var hw_transport_error_2 = require("@keystonehq/hw-transport-error");
Object.defineProperty(exports, "StatusCode", { enumerable: true, get: function () { return hw_transport_error_2.Status; } });
var chain_1 = require("./chain");
Object.defineProperty(exports, "Chain", { enumerable: true, get: function () { return chain_1.Chain; } });
__exportStar(require("./decorators"), exports);
__exportStar(require("./helper"), exports);
class TransportWebUSB {
    constructor(device, config) {
        var _b, _c, _d;
        _TransportWebUSB_instances.add(this);
        this.endpoint = 3;
        this.requestTimeout = constants_1.USBTimeout;
        this.maxPacketSize = constants_1.MAXUSBPackets;
        this.receive = (action, requestID) => __awaiter(this, void 0, void 0, function* () {
            var _e, _f, _g, _h, _j, _k, _l;
            if (!((_e = this.device) === null || _e === void 0 ? void 0 : _e.opened)) {
                return null;
            }
            const packagesBuffer = [];
            let counter = 0;
            let totalPackets = 0;
            let shouldContinue = true;
            do {
                const response = yield this.device.transferIn(this.endpoint, constants_1.USBPackageSize);
                if (response.status === 'babble') {
                    (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_RECEIVED_BABBLE);
                }
                const hasBuffer = !!((_f = response === null || response === void 0 ? void 0 : response.data) === null || _f === void 0 ? void 0 : _f.buffer);
                const isBufferEmpty = ((_h = (_g = response === null || response === void 0 ? void 0 : response.data) === null || _g === void 0 ? void 0 : _g.buffer) === null || _h === void 0 ? void 0 : _h.byteLength) === 0;
                const isCurrentAction = hasBuffer && !isBufferEmpty &&
                    new DataView(response.data.buffer).getUint16(constants_1.OFFSET_INS) === action &&
                    new DataView(response.data.buffer).getUint16(constants_1.OFFSET_LC) === requestID;
                if (!isCurrentAction) {
                    yield this.open();
                    continue;
                }
                shouldContinue = false;
                packagesBuffer.push(buffer_1.Buffer.from(response.data.buffer));
                totalPackets = new DataView(response.data.buffer).getUint16(constants_1.OFFSET_P1);
                counter += 1;
            } while (counter < totalPackets || shouldContinue);
            const result = (0, frame_1.decode)(packagesBuffer);
            if (result.status !== hw_transport_error_1.Status.RSP_SUCCESS_CODE) {
                throw new hw_transport_error_1.TransportError(`${(_k = (_j = (0, helper_1.safeJSONparse)(result.data)) === null || _j === void 0 ? void 0 : _j.payload) !== null && _k !== void 0 ? _k : 'unknown error'}`, (_l = result.status) !== null && _l !== void 0 ? _l : hw_transport_error_1.Status.RSP_FAILURE_CODE);
            }
            return (0, helper_1.safeJSONparse)(result.data);
        });
        this.open = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.device) {
                this.device = yield (0, webusb_1.requestKeystoneDevice)();
            }
            yield (0, webusb_1.open)(this.device);
        });
        this.close = () => __awaiter(this, void 0, void 0, function* () { var _m; return ((_m = this.device) === null || _m === void 0 ? void 0 : _m.opened) && (0, webusb_1.close)(this.device); });
        this.endpoint = (_b = config === null || config === void 0 ? void 0 : config.endpoint) !== null && _b !== void 0 ? _b : this.endpoint;
        this.requestTimeout = (_c = config === null || config === void 0 ? void 0 : config.timeout) !== null && _c !== void 0 ? _c : this.requestTimeout;
        this.maxPacketSize = (_d = config === null || config === void 0 ? void 0 : config.maxPacketSize) !== null && _d !== void 0 ? _d : this.maxPacketSize;
        this.device = device;
    }
    send(action, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _TransportWebUSB_instances, "m", _TransportWebUSB_send).call(this, action, data).finally(() => __awaiter(this, void 0, void 0, function* () {
                yield (0, webusb_1.close)(this.device);
            }));
        });
    }
}
exports.TransportWebUSB = TransportWebUSB;
_a = TransportWebUSB, _TransportWebUSB_instances = new WeakSet(), _TransportWebUSB_send = function _TransportWebUSB_send(action, data) {
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, webusb_1.open)(this.device);
        if (!((_b = this.device) === null || _b === void 0 ? void 0 : _b.opened)) {
            (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_DEVICE_NOT_OPENED);
        }
        if (!(0, helper_1.isUint8Array)(data) && !(0, helper_1.isString)(data)) {
            data = (0, helper_1.safeJSONStringify)(data);
        }
        const requestID = (0, helper_1.generateRequestID)();
        const packages = (0, frame_1.encode)(action, requestID, data);
        if (this.maxPacketSize < packages.length) {
            (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_DATA_TOO_LARGE);
        }
        let timeoutId;
        const timeout = new Promise((_, reject) => {
            timeoutId = setTimeout(() => reject(new hw_transport_error_1.TransportError(hw_transport_error_1.ErrorInfo[hw_transport_error_1.Status.ERR_TIMEOUT], hw_transport_error_1.Status.ERR_TIMEOUT)), this.requestTimeout);
        });
        const sendRequest = (() => __awaiter(this, void 0, void 0, function* () {
            try {
                do {
                    const res = yield this.device.transferOut(this.endpoint, packages[0]);
                    if (res.status !== 'ok')
                        (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_RESPONSE_STATUS_NOT_OK);
                    packages.shift();
                } while (packages.length > 0);
                return yield this.receive(action, requestID);
            }
            finally {
                clearTimeout(timeoutId);
            }
        }))();
        return Promise.race([sendRequest, timeout]);
    });
};
/**
 * The `requestPermission` static method is an asynchronous function that requests permission from the user to access a USB device.
 * It first checks if the WebUSB API is supported in the current environment.
 * Then, it requests access to a USB device.
 * After the device has been accessed, it is then closed.
 * In order to establish a connection with a USB device, the application must first request the user's permission.
 */
TransportWebUSB.requestPermission = () => __awaiter(void 0, void 0, void 0, function* () { return yield (0, webusb_1.close)(yield (0, webusb_1.request)()); });
/**
 * The `connect` static method is an asynchronous function that connects to a USB device.
 * It first checks if the WebUSB API is supported in the current environment.
 * Then, it retrieves a list of all USB devices that the application has permission to access using the `getKeystoneDevices` method.
 * The `getKeystoneDevices` method can only retrieve devices that the application has previously obtained permission to access using the `requestDevice` method.
 * Finally, it creates and returns a new `TransportWebUSB` object using the selected device.
 */
TransportWebUSB.connect = (config) => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, webusb_1.isSupported)();
    const devices = yield (0, webusb_1.getKeystoneDevices)();
    let device = null;
    if (devices.length > 1) {
        device = yield (0, webusb_1.requestKeystoneDevice)();
    }
    else {
        device = devices[0];
    }
    (0, webusb_1.initializeDisconnectListener)(device, config === null || config === void 0 ? void 0 : config.disconnectListener);
    return new _a(device, config);
});
__decorate([
    decorators_1.logMethod
], TransportWebUSB.prototype, "send", null);
function clearUSBState(device) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('Received error, resetting device...');
        try {
            if (device && device.opened) {
                // Release all interfaces
                if (device.configuration) {
                    yield device.releaseInterface(constants_1.USBInterfaceNumber);
                }
                // Close the device connection
                // await device.close();
            }
        }
        catch (error) {
            console.error("Error during USB state cleanup:", error);
        }
        finally {
            // Reset application state
            // device = null; // if reconnection is required, device can be set to null
            console.log('reset action done');
        }
    });
}
//# sourceMappingURL=index.js.map