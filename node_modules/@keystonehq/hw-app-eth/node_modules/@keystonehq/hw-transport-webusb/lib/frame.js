"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
const helper_1 = require("./helper");
const constants_1 = require("./constants");
const hw_transport_error_1 = require("@keystonehq/hw-transport-error");
const MAX_DATA_SIZE = 55;
const HEADER_SIZE = 9;
const dataParser = (buffer) => {
    /**
     * If the buffer length is 0, return null
     */
    if (buffer.length === 0)
        return null;
    const textDecoder = new TextDecoder('utf-8');
    return textDecoder.decode(buffer);
};
/**
 * Encode the data into packets
 * @param command
 * @param requestID
 * @param strData
 * @returns
 */
const encode = (command, requestID, data) => {
    if ((0, helper_1.isString)(data) && (!data || data.length === 0)) {
        const packet = new Uint8Array(9);
        packet[constants_1.OFFSET_CLA] = 0; // Fixed header
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_INS, command); // Command byte
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_P1, 1); // Total packets
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_P2, 0); // Current packet index
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_LC, requestID); // request ID
        return [packet];
    }
    const _data = (0, helper_1.isString)(data) ? new TextEncoder().encode(data) : data;
    const packets = [];
    const totalPackets = Math.ceil(_data.length / MAX_DATA_SIZE);
    for (let i = 0; i < totalPackets; i++) {
        const packetData = _data.slice(i * MAX_DATA_SIZE, (i + 1) * MAX_DATA_SIZE);
        const packetLen = HEADER_SIZE + packetData.length;
        const packet = new Uint8Array(packetLen);
        packet[constants_1.OFFSET_CLA] = 0; // Fixed header
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_INS, command); // Command byte
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_P1, totalPackets); // Total packets
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_P2, i); // Current packet index
        (0, helper_1.setUint16)(packet, constants_1.OFFSET_LC, requestID); // requesr ID
        packet.set(packetData, HEADER_SIZE); // Copy the data
        packets.push(packet);
    }
    return packets;
};
exports.encode = encode;
const parseEApduPacket = (uint8Array) => {
    if (uint8Array.length < HEADER_SIZE)
        (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_INVALID_PACKET_SIZE);
    const dataView = new DataView(uint8Array.buffer);
    const cla = dataView.getUint8(0);
    const ins = dataView.getUint16(constants_1.OFFSET_INS);
    const totalPackets = dataView.getUint16(constants_1.OFFSET_P1);
    const packetIndex = dataView.getUint16(constants_1.OFFSET_P2);
    const requestID = dataView.getUint16(constants_1.OFFSET_LC);
    const statusOffset = uint8Array.buffer.byteLength - 2;
    const status = dataView.getUint16(statusOffset);
    // Calculate packetDataSize by subtracting the length of the status from the length of the packet header
    const packetDataSize = statusOffset - constants_1.OFFSET_CDATA;
    const packetData = new Uint8Array(uint8Array.buffer, constants_1.OFFSET_CDATA, packetDataSize);
    const data = dataParser(packetData);
    return {
        cla,
        ins,
        totalPackets,
        packetIndex,
        requestID,
        data,
        status,
    };
};
/**
 * Decode the packets into data
 * @param buffers
 * @returns
 */
const decode = (buffers) => {
    const result = buffers
        .map((buffer) => parseEApduPacket(buffer))
        .sort(({ packetIndex: a }, { packetIndex: b }) => a - b)
        .reduce((acc, { data, status }) => ({ data: acc.data + data, status }), { data: '' });
    return result;
};
exports.decode = decode;
//# sourceMappingURL=frame.js.map