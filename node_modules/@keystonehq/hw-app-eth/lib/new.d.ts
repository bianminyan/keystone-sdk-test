import { TransportWebUSB } from '@keystonehq/hw-transport-webusb';
export default class Eth {
    private transport;
    private mfp;
    /**
     * Constructs a new instance of the class.
     *
     * @param transport - An object of type TransportWebUSB
     * @param mfp - Optional parameter of type string, default is undefined, but the mfp should exist in the signing process.
     */
    constructor(transport: TransportWebUSB, mfp?: string);
    private precheck;
    private sendToDevice;
    private checkDeviceLockStatus;
    /**
     * Retrieves the Ethereum address and related information based on the specified path
     *
     * @param path - The derivation path for the address
     * @param boolDisplay - A boolean indicating whether to display the QR code (default: false)
     * @param boolChainCode - A boolean indicating whether to include the chain code (default: undefined)
     * @param chainId - The ID of the Ethereum chain (default: undefined)
     * @returns A Promise object containing the address, public key, master fingerprint, and optionally the chain code
     */
    getAddress(path: string, boolDisplay?: boolean, boolChainCode?: boolean, chainId?: string): Promise<{
        address: string;
        publicKey: string;
        mfp: string;
        chainCode?: string;
    }>;
    private sign;
    /**
     * Sign a transaction using a specific path and raw transaction data
     *
     * @param path - The derivation path for the private key
     * @param rawTxHex - The raw transaction data in hexadecimal format
     * @param isLegacy - A boolean indicating whether the transaction is of the legacy type (default: false)
     * @returns A Promise object containing the signature data (r, s, v)
     * @throws Error if unable to sign the transaction
     */
    signTransaction(path: string, rawTxHex: string, isLegacy?: boolean): Promise<{
        r: string;
        s: string;
        v: string;
    }>;
    /**
     * Signs an EIP-712 message using a specific path and the JSON representation of the message.
     *
     * This function takes a derivation path and a JSON object representing the message, and returns
     * a Promise that resolves to an object containing the signature values (r, s, and v).
     *
     * @param path - The derivation path for the private key used to sign the message.
     * @param jsonMessage - A JavaScript object that represents the message to be signed.
     * This object should be structured according to the format required by EIP-712.
     * @return A Promise that resolves to an object with properties:
     *         - r: A string representing the "r" value of the signature.
     *         - s: A string representing the "s" value of the signature.
     *         - v: A string representing the "v" value of the signature.
     *
    */
    signEIP712Message(path: string, jsonMessage: Object): Promise<{
        r: string;
        s: string;
        v: string;
    }>;
    /**
     * Sign a personal message using a specific path and message content in hexadecimal format.
     *
     * This function takes a derivation path and a message represented by a hexadecimal string,
     * and returns a Promise that resolves to an object containing the signature values (r, s, v).
     *
     * @param path - The derivation path for the private key used to sign the message.
     * @param messageHex - A hexadecimal string that represents the message to be signed.
     * @return A Promise that resolves to an object with properties:
     *         - r: A string representing the "r" value of the signature.
     *         - s: A string representing the "s" value of the signature.
     *         - v: A string representing the "v" value of the signature.
     */
    signPersonalMessage(path: string, messageHex: string): Promise<{
        r: string;
        s: string;
        v: string;
    }>;
    /**
    * Retrieves the configuration information of the connected hardware device.
    *
    * This method sends a request to the device to get its version information,
    * then parses the response to extract the firmware version and wallet master fingerprint.
    *
    * @returns A Promise that resolves to an object containing:
    *          - version: A string representing the firmware version of the device
    *          - mfp: A string representing the master fingerprint of the wallet
    * @throws Will throw an error if the device communication fails or if the response cannot be parsed
    */
    getAppConfig(): Promise<any>;
}
//# sourceMappingURL=new.d.ts.map