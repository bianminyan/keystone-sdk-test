"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseExportedPublicKeyOrAddress = exports.parseTransaction = void 0;
const bc_ur_registry_eth_1 = require("@keystonehq/bc-ur-registry-eth");
const bc_ur_1 = require("@ngraveio/bc-ur");
const tx_1 = require("@ethereumjs/tx");
const hw_transport_error_1 = require("@keystonehq/hw-transport-error");
const parseTransaction = (data, tx) => {
    const decoder = new bc_ur_1.URDecoder();
    decoder.receivePart(data);
    if (!decoder.isComplete()) {
        (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_UR_INCOMPLETE);
    }
    const resultUr = decoder.resultUR();
    if (resultUr.type !== 'eth-signature') {
        (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_UR_INVALID_TYPE);
    }
    const ethSignature = bc_ur_registry_eth_1.ETHSignature.fromCBOR(Buffer.from(resultUr.cbor.toString('hex'), 'hex'));
    const signature = ethSignature.getSignature();
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const v = signature.slice(64);
    const txJson = tx.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx.type;
    const transaction = tx_1.TransactionFactory.fromTxData(txJson, {
        common: tx.common,
    });
    return transaction;
};
exports.parseTransaction = parseTransaction;
const parseExportedPublicKeyOrAddress = (data) => {
    const decoder = new bc_ur_1.URDecoder();
    decoder.receivePart(data);
    const result = decoder.resultUR();
    const cbor = result.cbor.toString('hex');
    if (result.type === 'crypto-hdkey') {
        return bc_ur_registry_eth_1.CryptoHDKey.fromCBOR(Buffer.from(cbor, 'hex'));
    }
    else {
        return bc_ur_registry_eth_1.CryptoAccount.fromCBOR(Buffer.from(cbor, 'hex'));
    }
};
exports.parseExportedPublicKeyOrAddress = parseExportedPublicKeyOrAddress;
//# sourceMappingURL=ur-parser.js.map