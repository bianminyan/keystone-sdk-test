"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransportWebUSB_instances, _a, _TransportWebUSB_send;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createKeystoneTransport = exports.TransportWebUSB = void 0;
const hw_transport_usb_1 = require("@keystonehq/hw-transport-usb");
const hw_transport_usb_2 = require("@keystonehq/hw-transport-usb");
const hw_transport_usb_3 = require("@keystonehq/hw-transport-usb");
const hw_transport_error_1 = require("@keystonehq/hw-transport-error");
const buffer_1 = require("buffer");
const keystoneDevices = [
    {
        vendorId: hw_transport_usb_2.keystoneUSBVendorId,
    },
];
class TransportWebUSB {
    static getKeystoneDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            const devices = yield navigator.usb.getDevices();
            return devices.filter((d) => d.vendorId === hw_transport_usb_2.keystoneUSBVendorId);
        });
    }
    static getFirstKeystoneDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            const existingDevices = yield this.getKeystoneDevices();
            if (existingDevices.length > 0)
                return existingDevices[0];
            return requestKeystoneDevice();
        });
    }
    static isSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(navigator === null || navigator === void 0 ? void 0 : navigator.usb) || typeof navigator.usb.getDevices !== 'function')
                (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_NOT_SUPPORTED);
            if ((0, hw_transport_usb_3.isEmpty)(yield this.getKeystoneDevices()))
                (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_DEVICE_NOT_FOUND);
            return true;
        });
    }
    constructor(device, config) {
        var _b, _c, _d;
        _TransportWebUSB_instances.add(this);
        this.endpoint = 3;
        this.requestTimeout = hw_transport_usb_2.USBTimeout;
        this.maxPacketSize = hw_transport_usb_2.MAXUSBPackets;
        this.receive = (action, requestID) => __awaiter(this, void 0, void 0, function* () {
            var _e, _f, _g, _h, _j, _k, _l;
            if (!((_e = this.device) === null || _e === void 0 ? void 0 : _e.opened)) {
                return null;
            }
            const packagesBuffer = [];
            let counter = 0;
            let totalPackets = 0;
            let shouldContinue = true;
            do {
                const response = yield this.device.transferIn(this.endpoint, hw_transport_usb_2.USBPackageSize);
                if (response.status === 'babble') {
                    (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_RECEIVED_BABBLE);
                }
                const hasBuffer = !!((_f = response === null || response === void 0 ? void 0 : response.data) === null || _f === void 0 ? void 0 : _f.buffer);
                const isBufferEmpty = ((_h = (_g = response === null || response === void 0 ? void 0 : response.data) === null || _g === void 0 ? void 0 : _g.buffer) === null || _h === void 0 ? void 0 : _h.byteLength) === 0;
                const isCurrentAction = hasBuffer && !isBufferEmpty &&
                    new DataView(response.data.buffer).getUint16(hw_transport_usb_2.OFFSET_INS) === action &&
                    new DataView(response.data.buffer).getUint16(hw_transport_usb_2.OFFSET_LC) === requestID;
                if (!isCurrentAction) {
                    yield this.open();
                    continue;
                }
                shouldContinue = false;
                packagesBuffer.push(buffer_1.Buffer.from(response.data.buffer));
                totalPackets = new DataView(response.data.buffer).getUint16(hw_transport_usb_2.OFFSET_P1);
                counter += 1;
            } while (counter < totalPackets || shouldContinue);
            const result = (0, hw_transport_usb_1.decode)(packagesBuffer);
            if (result.status !== hw_transport_error_1.Status.RSP_SUCCESS_CODE) {
                throw new hw_transport_error_1.TransportError(`${(_k = (_j = (0, hw_transport_usb_3.safeJSONparse)(result.data)) === null || _j === void 0 ? void 0 : _j.payload) !== null && _k !== void 0 ? _k : 'unknown error'}`, (_l = result.status) !== null && _l !== void 0 ? _l : hw_transport_error_1.Status.RSP_FAILURE_CODE);
            }
            return (0, hw_transport_usb_3.safeJSONparse)(result.data);
        });
        this.open = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.device) {
                this.device = yield requestKeystoneDevice();
            }
            yield open(this.device);
        });
        this.close = () => __awaiter(this, void 0, void 0, function* () {
            var _m;
            if ((_m = this.device) === null || _m === void 0 ? void 0 : _m.opened) {
                yield close(this.device);
            }
        });
        this.endpoint = (_b = config === null || config === void 0 ? void 0 : config.endpoint) !== null && _b !== void 0 ? _b : this.endpoint;
        this.requestTimeout = (_c = config === null || config === void 0 ? void 0 : config.timeout) !== null && _c !== void 0 ? _c : this.requestTimeout;
        this.maxPacketSize = (_d = config === null || config === void 0 ? void 0 : config.maxPacketSize) !== null && _d !== void 0 ? _d : this.maxPacketSize;
        this.device = device;
    }
    send(action, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _TransportWebUSB_instances, "m", _TransportWebUSB_send).call(this, action, data).finally(() => __awaiter(this, void 0, void 0, function* () {
                yield close(this.device);
            }));
        });
    }
}
exports.TransportWebUSB = TransportWebUSB;
_a = TransportWebUSB, _TransportWebUSB_instances = new WeakSet(), _TransportWebUSB_send = function _TransportWebUSB_send(action, data) {
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        yield open(this.device);
        if (!((_b = this.device) === null || _b === void 0 ? void 0 : _b.opened)) {
            (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_DEVICE_NOT_OPENED);
        }
        if (!(0, hw_transport_usb_3.isUint8Array)(data) && !(0, hw_transport_usb_3.isString)(data)) {
            data = (0, hw_transport_usb_3.safeJSONStringify)(data);
        }
        const requestID = (0, hw_transport_usb_3.generateRequestID)();
        const packages = (0, hw_transport_usb_1.encode)(action, requestID, data);
        if (this.maxPacketSize < packages.length) {
            (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_DATA_TOO_LARGE);
        }
        let timeoutId;
        const timeout = new Promise((_, reject) => {
            timeoutId = setTimeout(() => reject(new hw_transport_error_1.TransportError(hw_transport_error_1.ErrorInfo[hw_transport_error_1.Status.ERR_TIMEOUT], hw_transport_error_1.Status.ERR_TIMEOUT)), this.requestTimeout);
        });
        const sendRequest = (() => __awaiter(this, void 0, void 0, function* () {
            try {
                do {
                    const res = yield this.device.transferOut(this.endpoint, packages[0]);
                    if (res.status !== 'ok')
                        (0, hw_transport_error_1.throwTransportError)(hw_transport_error_1.Status.ERR_RESPONSE_STATUS_NOT_OK);
                    packages.shift();
                } while (packages.length > 0);
                return yield this.receive(action, requestID);
            }
            finally {
                clearTimeout(timeoutId);
            }
        }))();
        return Promise.race([sendRequest, timeout]);
    });
};
/**
 * The `requestPermission` static method is an asynchronous function that requests permission from the user to access a USB device.
 * It first checks if the WebUSB API is supported in the current environment.
 * Then, it requests access to a USB device.
 * After the device has been accessed, it is then closed.
 * In order to establish a connection with a USB device, the application must first request the user's permission.
 */
TransportWebUSB.requestPermission = () => __awaiter(void 0, void 0, void 0, function* () { return yield close(yield request()); });
/**
 * The `connect` static method is an asynchronous function that connects to a USB device.
 * It first checks if the WebUSB API is supported in the current environment.
 * Then, it retrieves a list of all USB devices that the application has permission to access using the `getKeystoneDevices` method.
 * The `getKeystoneDevices` method can only retrieve devices that the application has previously obtained permission to access using the `requestDevice` method.
 * Finally, it creates and returns a new `TransportWebUSB` object using the selected device.
 */
TransportWebUSB.connect = (config) => __awaiter(void 0, void 0, void 0, function* () {
    yield _a.isSupported();
    const devices = yield _a.getKeystoneDevices();
    let device = null;
    if (devices.length > 1) {
        device = yield requestKeystoneDevice();
    }
    else {
        device = devices[0];
    }
    initializeDisconnectListener(device, config === null || config === void 0 ? void 0 : config.disconnectListener);
    return new _a(device, config);
});
__decorate([
    hw_transport_usb_1.logMethod
], TransportWebUSB.prototype, "send", null);
const initializeDisconnectListener = (device, disconnectListener) => {
    const onDisconnect = (e) => {
        if (device === e.device) {
            disconnectListener && disconnectListener(device);
            close(device);
            navigator.usb.removeEventListener('disconnect', onDisconnect);
        }
    };
    navigator.usb.addEventListener('disconnect', onDisconnect);
};
function createKeystoneTransport(timeout = 100000) {
    return __awaiter(this, void 0, void 0, function* () {
        if ((yield TransportWebUSB.getKeystoneDevices()).length <= 0) {
            try {
                yield TransportWebUSB.requestPermission();
            }
            catch (e) {
                throw new Error('USB_PERMISSION_NOT_AVAILABLE');
            }
        }
        const transport = yield TransportWebUSB.connect({
            timeout,
        });
        yield transport.close();
        return transport;
    });
}
exports.createKeystoneTransport = createKeystoneTransport;
function selectDefaultConfiguration(device) {
    return __awaiter(this, void 0, void 0, function* () {
        if (device.configuration === null) {
            yield device.selectConfiguration(hw_transport_usb_2.USBConfigurationValue);
        }
    });
}
function requestKeystoneDevice() {
    return __awaiter(this, void 0, void 0, function* () {
        const device = yield navigator.usb.requestDevice({
            filters: keystoneDevices,
        });
        return device;
    });
}
const open = (device) => __awaiter(void 0, void 0, void 0, function* () {
    yield device.open();
    yield selectDefaultConfiguration(device);
    yield gracefullyResetDevice(device);
    try {
        yield device.claimInterface(hw_transport_usb_2.USBInterfaceNumber);
    }
    catch (e) {
        yield close(device);
        throw e;
    }
    return device;
});
function gracefullyResetDevice(device) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield device.reset();
        }
        catch (err) {
            console.warn(err);
        }
    });
}
const request = () => __awaiter(void 0, void 0, void 0, function* () {
    const device = yield requestKeystoneDevice();
    return yield open(device);
});
const close = (device) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield device.releaseInterface(hw_transport_usb_2.USBInterfaceNumber);
        yield gracefullyResetDevice(device);
        yield device.close();
    }
    catch (err) {
        console.warn(err);
    }
});
//# sourceMappingURL=webusb.js.map